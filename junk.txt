
	def score(self,O, R, S):

		prob_Rk

		#M-step - estimate parameters Î˜G

		#E-step - calculate P()

		return random.random() 

	def build_model(self, feature_vectors, labels):
		
		score_max = 0
		iteration_improvement = 0

		#Domain size variables
		R = 0
		S = [0 for _ in range(len(labels))]
		O = feature_vectors

		while (iteration_improvement < 10):
			R = R + 1 #increase domain size
			S_mod = S
			new_score = self.score(O,R,S_mod)

			for _ in range(len(labels)): #increase domain size of labels
				S_mod_mod = S_mod
				S_mod_mod[_] = S_mod_mod[_] + 1

				new_label_score = self.score(O,R,S_mod_mod)
				while (new_label_score > new_score and sum(S_mod_mod) < R + 1):
					S_mod_mod[_] = S_mod_mod[_] + 1
					S_mod[_] = S_mod[_] + 1
					new_score = new_label_score
					new_label_score = self.score(O,R,S_mod_mod)

			if (new_score > score_max):
				score_max = new_score
				iteration_improvement = 0
				S = S_mod
			else:
				iteration_improvement = iteration_improvement+1


		return S


	#Get boudning box for poly
	#Get open edges
	#match eve placement ry component (energy minimizer)
	#Energy minimize totalof components
	#for non-matched components: create hole
	#Stich using triangles

import mesh_assembly
m_a = mesh_assembly.MeshAssembler()
k = m_a.generative_adversarial_net([[23,3],[234,34]],0)
